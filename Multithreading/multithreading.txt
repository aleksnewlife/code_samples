
0. Многопоточность - это паралельное выполнение цепей кода (в случае с многопроцессорными машинами, на однопросцессорных это эмулируется)
    1. Каждое приложение имеет процес и несколько потоков (первичный и вторичные)
    2. Каждый поток имеет уникальный идентификатор
    3. Потоки можно создавать и завершать (как по выходу из метода потока так и принудительно по идентификатору потока)
    4. Потоки можно приостанаваливать (как основной так и второстепенные)

1. Потоки используются для
    1. Для выполнения фоновых/отложенных задач (чтение/запись сети, запись в базу)
    2. Для выполнения паралельных вычислений (разного рода просчетов, сортировок, преобразований)

2. Разделяемые ресурсы и синхронизация доступа (гонки за данными)
    1. Разделяемые ресурсы это ресурсы, которые используются одновременно разными потоками/процессами (обычно это память, но могут быть и устройства к примеру)
    2. Раскажу о рязделяемых ресурсах как о пямяти (контейнерах с данными)
    3. Каждый поток может как читать ресурс так и изменять его (может только читать, когда он изменяет то обычно и читает)
    4. Для структур данных есть такое понятие как ИНВАРИАНТ:
        инварианта — утверждения о структуре данных, которое всегда должно быть истинным, например, «значение этой переменной равно числу элементов в списке». 
        В процессе обновления инварианты часто нарушаются, особенно если структура данных сложна или обновление затрагивает несколько значений.
    5. К примеру у нас есть массив, который читают и изменяют два потока.
       - Инвариантом здесь будет переменная размера массива, и при изменении длины массива одним из потоков она станет невалидной без блокировки доступа к ресурсу.
       - Навалидные состояния(а то и неопределенное поведение) из-за неупорядоченного доступу к массиву можно получить очень просто
         1. Один поток может удалить элементы внутри массива, все элементы сместятся вперед и мы получим не валидные данные для другого потока.
         2. Если принять что у нас массив имеет констунтную длину, то можно всеравное можно получить невалидные данные в одном из потоков в моменте, когда
         один поток меняет а другой читает смежные элементы массива. К примеру первый читает 2,3,4,5 второй меняет 4,5,6,7
         3. Операци чтения/изменения массива может состоять из нескольких этапов, к примеру:
            = чтение:
                - читает размер массива
                - проверяет попадает ои индекс элемента в массив
                - читает ячейку
            = запись/удаление
                - читает размер массива
                - проверяет попадает ли индекс элемента в массив
                - записывает элемент 
                    или же 
                - удаляет элемент и сдвигает все элементы вперед (тоже не атомарная операция)
                    или же
                - увеличивает размер массива и добавляет элементв в конец
            - по этому любой поток в любой момент времени может находится на любом этапе операции, что приведет нас к нарушению инвариантов
    6. По этому нужно прибегать к синхронизации доступа к разделяемому ресурсу - массиву, 
        "Что бы быть в ситуации, когда инварианты не нарушены"
        " Синхронизация доступа выполняется посредством использорвания примитивов синхронизации, которые позволяют организовать правильный доступ к ресурсу"
    7. Или же изменить структуру данных так, что бы инварианты не нарушались при гонке за ресурсы

3. Примитивы синхронизации и их использование
    0. volatile
    1. Мютексы-Критические секции/Именованные мютексы
        - Мютекс имеет 2 состояния: заблокирован и разблокирован
        - Когда мютекс заблокировн одним потоком, и второй поток пытается его заблокировать со своей стороны, поток останавливает и ожидает освобождения мютекса
        - таким образом организовывается процесс доступа к ресурсу (! показать на примере массива)

        "! Необходимо парвильно выбирать гранулярность блокировки, тем самым позволить другим захватывать ресурс не ожидая"
        "! Можно прибегать к иерархий мютексов разделив архитектуру на слои, когда блокировка мютекса нижнего уровня, не дает заблокировать мютекс верхнего уровня"
    2. Условные переменные/События
        - Принцип работы условных переменных следующий:
            - когда переменная ожидает сигнал, мютекс освобождается
            - когда приходит сигнал, мютекс захватывается
            - сигнал может быть послан одиночный, тогда сигнал получает только одна случайная переменная в одном из потоков, 
            - в другом случае сигнал можно послать всем, и все переменные получат сигнал
        - ложные срабатывания
    3. Симофоры
        - это такая себе атомарная перменнная с сигнализацией
        - если она равна 0, все потоки ждут когда переменная будет больше ноля
        - когда переменная увеличилась, тогда один или несколько потоков пытаются отнять единицу, и если у них это получается, они разблокируются и продолжают выполнение
        - таким образом можно дозировать, сколько потоков должно обработать данные
4. Атомарные переменные
    - переменные с атомарным доступом (атомарные флаги)
    - инкапсулируют в себе данные, которые можно безопасно использовать между потоками без гонки за данными
    - атомарные переменные обеспечиваются шиной данных и процессором
5. Дедлоки (избегание дедлоков, взаимных замыканий)
    - Это когда захват пары и более мютексов происходит взаимно разными потоками (поток 1 захватывает А и ожидает освобождение В, поток 2 захватывает В и ожидает освобождение А)
    - пример с барабаном и палочками
    - избежать можно:
        - одновременной блокировкой двух мютексов
        или же
        - захватом мютексов в одинаковой последовательности
6. Lock-free подход и принцип один пишет много читают
    ABA
    Очередь на примере RingBuffer
    thread::yield;

